# LearnDocker

  https://habr.com/ru/post/310460/

## Установка на винде 10 (WSL2)
  wsl --install (~3Гб)  
  https://docs.docker.com/desktop/install/windows-install/  
проверка что работает: docker run hello-world

## Запуск контейнера
docker run [-it]/[-d] [-P]/[-p "порт хоста:порт контейнера/протокол" например "80:8000/tcp"][имя контейнера] [команда после запуска, например bush]  
-it - подключение локального ввода в tty контейнера  
-d - detach терминал от контейнера. можно закрыть консоль а контейнер будет работать  
-P - пробросит на хост ВСЕ открытые порты контейнера на случайные номера. Посмотреть на какие docker port [CONTAINER]  

## Dockerfile и создание своих образов
Набор команд по которому из образа можно получить новый образ  
FROM [имя начального образа, например openjdk:17] задаёт исходный образ  
EXPOSE [номер порта / tcp или udp(по умолчанию TCP), например 80] декларирует используемый в контейнере порт для его проброса на хост  
RUN [команда линух например apt-ge -yqq install java-tools] выполянет произвольную команду  
WORKDIR [путь внутри контейнера] задаёт рабочую папку, всё выполняется в ней  
COPY [откуда с машины хоста, где . это папка где сам Dockerfile] [куда вконтейнер, где . это WORKDIR]  
CMD ["[команда]", "[параметр1]", "[параметр2]", ... "[параметрN]"] например CMD ["java","-jar","App.jar"] задаёт что делать после запуска контейнера (обычно запуск приложения)  

docker build [папка с Dockerfile, желательно . и запускать в папке с ним] -t [имя нового образа]  


## Полезные команды
Остановить контейнер: docker stop [CONTAINER ID]  
Поиска на ХАБе подходящих образов: docker search [ключевое словоб например java]  
Список доступных локально образов: docker images  
Список контейнеров: docker ps -a  
Удаление контейнера: docker rm [CONTAINER ID]  

## Volume - разделы для хранения изменяемых данных
После перезапуска контейнер потеряет все изменения внутри своей ФС.  
Поэтому нужно внешнее хранилище под данные. Можно проброс папок но правильее volume - оно подключено к контейнеру но независимо от него.  
https://docs.docker.com/storage/volumes/  
docker volume create [имя для нового раздела] создать раздел  
docker volume ls получить список доступных разделов  
docker run [... остальные параметры] -v [имя раздела]:[точка для монтирования]:[опционально параметры например ro] подключение к контейнеру например -v myvol1:/myapp  

## Bind - проброс папки хоста в контейнер
Рекомендуется только что бы разово забрат какие-то данные  
docker run [... остальные параметры] --mount type=bind,source=[путь на хосте, где "$(pwd)" - текущая папка, например $(pwd)/src],target=[точка для монтирования, например /app]  

## Виртуальные сети
docker network create [имя новой сети, например myInternalNetwork] создать сеть для контейнеров  
docker network ls получить список доступных сетей  
docker network inspect [имя сети, например myInternalNetwork] даст инфу о сети и подключенных на неё контейнерах  
docker run [... остальные параметры] --net [имя сети, например myInternalNetwork] --name [имя для контейнера, по нему он доступен в сети, например myContainer] запуск контейнера с подключением к сети, будет доступен по имени контейнера.  

## docker compose - многоконтейнерные приложения
Управление запуском нескольких контейнеров как одного приложения.  
Конфигурится файлом docker-compose.yml  
Сеть можно не указывать - всегда создаёт новую сеть bridge и там запускает все контейнеры.  
docker-compose up запуск, выполнять в папке с docker-compose.yml  
docker-compose up -d запуск в режиме detach - терминал к ним не подключен, они просто работают.   
docker-compose ps показать список запущенных в compose контейнеров  
docker-compose stop остановить, выполнять в папке с docker-compose.yml  
Пример docker-compose.yml  
```
version: "3"
services:
  database: //имя для сервиса, так будем его видеть в сети
    image: postgres //имя образа для контейнера. ОБЯЗАТЕЛЬНО.
    volumes:
      - my_volume_bd:/opt/database //подключение раздела
    ports:
      - 5432:5432 //проброс порта на ХОСТ. если нужно только для внутри сети контейнеров - не надо проброс.
  web_app: //имя для сервиса, так будем его видеть в сети
    image: my_web_app //имя образа для контейнера. ОБЯЗАТЕЛЬНО.
    command: java -jar my_app.jar // команда для запуска после поднятия контейнера
    depends_on:
      - database  //указывает зависимости - при запуске сначала запустит их а потом уже зависимый сервис
    volumes:
      - type: bind  //проброс папки с хоста
        source: .
        target: /opt/static
    ports:
      - 80:8080 //проброс порта на ХОСТ. если нужно только для внутри сети контейнеров - не надо проброс.
volumes:
  my_volume_bd: //описываем храналище. Оно создаётся при первом запуске и подключается каждый раз то же самое
    external: true //указываем если создавать не надо и мы его создадим сами и оно уже есть в docker, только подключить при запуске
```
